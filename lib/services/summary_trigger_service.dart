// ========================================
// lib/services/summary_trigger_service.dart
// ========================================
import '../models/item_job.dart';
import '../services/storage_service.dart';
import '../services/summary_generation_service.dart';

class SummaryTriggerService {

  // Check if item has enough data to generate summary
  static bool shouldGenerateSummary(ItemJob item) {
    final analysisResult = item.analysisResult;
    if (analysisResult == null) return false;

    // Don't regenerate if already has a user-edited summary
    if (analysisResult['summary']?['userEdited'] == true) return false;

    // Check for minimum data requirements
    final hasScrapedData = analysisResult['scrapedSources'] != null &&
        (analysisResult['scrapedSources'] as List).length >= 2;

    final hasOcrData = item.ocrResults != null && item.ocrResults!.isNotEmpty;

    final hasClassification = item.imageClassification != null &&
        item.imageClassification!['packaging']?.isNotEmpty == true;

    // Generate summary if we have at least 2 data sources
    int dataSourceCount = 0;
    if (hasScrapedData) dataSourceCount += 2; // Scraped data counts as 2
    if (hasOcrData) dataSourceCount += 1;
    if (hasClassification) dataSourceCount += 1;

    return dataSourceCount >= 2;
  }

  // Automatically trigger summary generation when conditions are met
  static Future<ItemJob?> checkAndGenerateSummary(ItemJob item) async {
    if (!shouldGenerateSummary(item)) return null;

    try {
      // Collect all available data sources
      final dataSources = _collectDataSources(item);

      // Generate item summary
      final summaryResult = await SummaryGenerationService.generateItemSummary(
        dataSources: dataSources,
        userDescription: item.userDescription,
        searchKeywords: item.searchDescription,
      );

      // Generate pricing summary
      final pricingResult = SummaryGenerationService.generatePricingSummary(dataSources);

      // Update item with generated summaries
      Map<String, dynamic> updatedAnalysisResult = Map.from(item.analysisResult ?? {});
      updatedAnalysisResult['summary'] = summaryResult;
      updatedAnalysisResult['pricing'] = pricingResult;
      updatedAnalysisResult['autoGeneratedAt'] = DateTime.now().toIso8601String();

      final updatedItem = item.copyWith(analysisResult: updatedAnalysisResult);

      // Save updated item
      await StorageService.saveJob(updatedItem);

      return updatedItem;

    } catch (e) {
      print('Auto-summary generation error: $e');
      return null;
    }
  }

  // Collect all data sources from the item
  static List<Map<String, dynamic>> _collectDataSources(ItemJob item) {
    List<Map<String, dynamic>> sources = [];

    final analysisResult = item.analysisResult;
    if (analysisResult == null) return sources;

    // Add scraped web sources
    final scrapedSources = analysisResult['scrapedSources'] as List? ?? [];
    for (var source in scrapedSources) {
      if (source['data'] != null) {
        final sourceData = source['data'] as Map<String, dynamic>;
        sources.add({
          'url': sourceData['url'],
          'title': sourceData['title'],
          'fullText': sourceData['fullText'],
          'prices': sourceData['prices'],
          'specifications': sourceData['specifications'],
          'scrapedAt': source['timestamp'],
          'confidence': 0.8,
          'dataType': 'web_scrape',
        });
      }
    }

    // Add OCR data as a source
    if (item.ocrResults != null && item.ocrResults!.isNotEmpty) {
      final combinedOcrText = item.ocrResults!.values.join('\n\n--- IMAGE BREAK ---\n\n');
      sources.add({
        'url': 'local://ocr',
        'title': 'OCR Extracted Text',
        'fullText': combinedOcrText,
        'prices': [], // OCR might contain prices
        'specifications': [],
        'scrapedAt': DateTime.now().toIso8601String(),
        'confidence': 0.6,
        'dataType': 'ocr',
      });
    }

    // Add barcode/UPC data
    if ((item.barcodes?.isNotEmpty == true) || (item.upcs?.isNotEmpty == true)) {
      final codes = [...(item.barcodes ?? []), ...(item.upcs ?? [])];
      sources.add({
        'url': 'local://barcodes',
        'title': 'Product Codes',
        'fullText': 'Product codes found: ${codes.join(', ')}',
        'prices': [],
        'specifications': [],
        'scrapedAt': DateTime.now().toIso8601String(),
        'confidence': 0.9,
        'dataType': 'barcode',
      });
    }

    return sources;
  }

  // Get summary generation status for UI
  static Map<String, dynamic> getSummaryStatus(ItemJob item) {
    final analysisResult = item.analysisResult;

    if (analysisResult?['summary'] != null) {
      final summary = analysisResult!['summary'] as Map<String, dynamic>;
      return {
        'hasData': true,
        'isGenerated': true,
        'isUserEdited': summary['userEdited'] ?? false,
        'confidence': summary['confidence'] ?? 0.0,
        'generatedAt': summary['generatedAt'],
        'lastEditedAt': summary['lastEditedAt'],
        'requiresMoreData': summary['requiresMoreData'] ?? false,
      };
    }

    final shouldGenerate = shouldGenerateSummary(item);
    final dataSources = _collectDataSources(item);

    return {
      'hasData': false,
      'isGenerated': false,
      'canGenerate': shouldGenerate,
      'dataSourceCount': dataSources.length,
      'needsMoreSources': dataSources.length < 2,
      'missingDataTypes': _getMissingDataTypes(item),
    };
  }

  static List<String> _getMissingDataTypes(ItemJob item) {
    List<String> missing = [];

    if (item.ocrResults?.isEmpty != false) {
      missing.add('OCR text from packaging');
    }

    final scrapedCount = (item.analysisResult?['scrapedSources'] as List?)?.length ?? 0;
    if (scrapedCount < 2) {
      missing.add('Web scraped data (need ${2 - scrapedCount} more sources)');
    }

    if (item.barcodes?.isEmpty != false && item.upcs?.isEmpty != false) {
      missing.add('Product codes (barcodes/UPC)');
    }

    return missing;
  }

  // Force regenerate summary (for manual trigger)
  static Future<ItemJob?> forceRegenerateSummary(ItemJob item) async {
    final dataSources = _collectDataSources(item);

    if (dataSources.isEmpty) {
      throw Exception('No data sources available for summary generation');
    }

    try {
      // Generate new summaries
      final summaryResult = await SummaryGenerationService.generateItemSummary(
        dataSources: dataSources,
        userDescription: item.userDescription,
        searchKeywords: item.searchDescription,
      );

      final pricingResult = SummaryGenerationService.generatePricingSummary(dataSources);

      // Update item
      Map<String, dynamic> updatedAnalysisResult = Map.from(item.analysisResult ?? {});
      updatedAnalysisResult['summary'] = {
        ...summaryResult,
        'userEdited': false, // Reset user edit flag
        'regeneratedAt': DateTime.now().toIso8601String(),
      };
      updatedAnalysisResult['pricing'] = {
        ...pricingResult,
        'userEdited': false,
        'regeneratedAt': DateTime.now().toIso8601String(),
      };

      final updatedItem = item.copyWith(analysisResult: updatedAnalysisResult);
      await StorageService.saveJob(updatedItem);

      return updatedItem;

    } catch (e) {
      print('Force regenerate summary error: $e');
      rethrow;
    }
  }
}